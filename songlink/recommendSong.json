{"cells": [{"cell_type": "code", "execution_count": 6, "id": "b58ddea1", "metadata": {}, "outputs": [{"name": "stderr", "output_type": "stream", "text": ["C:\\Users\\HOME\\anaconda3\\lib\\site-packages\\sklearn\\base.py:450: UserWarning: X does not have valid feature names, but RandomForestClassifier was fitted with feature names\n", "  warnings.warn(\n"]}, {"name": "stdout", "output_type": "stream", "text": ["\ud1a4==\ub0a8\uc131\uc801\n", "[[104.34616026]] -> \uc608\uc0c1 \ucd5c\uace0 \uc625\ud0c0\ube0c: ['G#2']\n", "\uccab \ubc88\uc9f8 \ubd84\ub958 \uacb0\uacfc: [['10cm-\uc2a4\ud1a0\ucee4']]\n", "\ub450 \ubc88\uc9f8 \ubd84\ub958 \uacb0\uacfc: [['M.C The Max-\uc5b4\ub514\uc5d0\ub3c4']]\n", "\uc138 \ubc88\uc9f8 \ubd84\ub958 \uacb0\uacfc: [['MSG\uc6cc\ub108\ube44(M.O.M)-\ub4e3\uace0 \uc2f6\uc744\uae4c']]\n"]}, {"name": "stderr", "output_type": "stream", "text": ["C:\\Users\\HOME\\AppData\\Local\\Temp\\ipykernel_39420\\134098807.py:150: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n", "  input_features = np.array([mfcc_mean[0],mfcc_mean[1], mfcc_mean[2],mfcc_mean[3],mfcc_mean[4],mfcc_mean[5],mfcc_mean[6],mfcc_mean[7],mfcc_mean[8],mfcc_mean[9],mfcc_mean[10],mfcc_mean[11],mfcc_mean[12],mfcc_mean[13],mfcc_mean[14],mfcc_mean[15],mfcc_mean[16],mfcc_mean[17],mfcc_mean[18],mfcc_mean[19],spectral_centroids, spectral_bandwidth,spectral_contrast, spectral_rolloff, meanfreq,\n", "C:\\Users\\HOME\\anaconda3\\lib\\site-packages\\sklearn\\base.py:450: UserWarning: X does not have valid feature names, but DecisionTreeClassifier was fitted with feature names\n", "  warnings.warn(\n", "C:\\Users\\HOME\\anaconda3\\lib\\site-packages\\sklearn\\base.py:450: UserWarning: X does not have valid feature names, but DecisionTreeClassifier was fitted with feature names\n", "  warnings.warn(\n", "C:\\Users\\HOME\\AppData\\Local\\Temp\\ipykernel_39420\\134098807.py:163: UserWarning: Boolean Series key will be reindexed to match DataFrame index.\n", "  X_updated2=X_updated[~y.isin(result2)]\n", "C:\\Users\\HOME\\anaconda3\\lib\\site-packages\\sklearn\\base.py:450: UserWarning: X does not have valid feature names, but DecisionTreeClassifier was fitted with feature names\n", "  warnings.warn(\n"]}], "source": ["import pandas as pd\n", "import numpy as np\n", "import librosa\n", "from sklearn.model_selection import train_test_split\n", "from sklearn.metrics import accuracy_score\n", "from sklearn.tree import DecisionTreeClassifier\n", "from sklearn.preprocessing import LabelEncoder\n", "from sklearn.ensemble import RandomForestClassifier\n", "\n", "y1, sr = librosa.load(\"user_voice3high.wav\",sr=44000)\n", "\n", "data = pd.read_csv(\"DF.csv\")\n", "data = data.fillna(data.mean())\n", "\n", "X = data.iloc[:, :-1]\n", "y = data.iloc[:, -1]\n", "\n", "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=23)\n", "\n", "\n", "rfm=RandomForestClassifier(n_estimators=200, max_depth=3,random_state=105)\n", "rfm.fit(X_train, y_train)\n", "y_pred = rfm.predict(X_test)\n", "acc = accuracy_score(y_test, y_pred)\n", "\n", "##############################################################################################\n", "\n", "\n", "mfcc = librosa.feature.mfcc(y=y1, sr=sr, n_mfcc=20)\n", "\n", "spectral_centroids = librosa.feature.spectral_centroid(y=y1, sr=sr)\n", "\n", "spectral_bandwidth = librosa.feature.spectral_bandwidth(y=y1, sr=sr)\n", "\n", "spectral_contrast = librosa.feature.spectral_contrast(y=y1, sr=sr)\n", "\n", "spectral_rolloff = librosa.feature.spectral_rolloff(y=y1, sr=sr)\n", "\n", "meanfreq = np.mean(spectral_centroids)\n", "\n", "maxfreq = np.max(spectral_centroids)\n", "\n", "\n", "mfcc_mean = np.mean(mfcc[:, 1:], axis=1).tolist()\n", "spectral_centroids = np.mean(spectral_centroids[spectral_centroids > 0])\n", "spectral_bandwidth = np.mean(spectral_bandwidth[spectral_bandwidth > 0])\n", "spectral_contrast = np.mean(spectral_contrast[spectral_contrast > 0], axis=0).tolist()\n", "spectral_rolloff = np.mean(spectral_rolloff[spectral_rolloff > 0])\n", "meanfreq = np.mean(meanfreq[meanfreq > 0])\n", "maxfreq = np.mean(maxfreq[maxfreq > 0])\n", "\n", "input_features = np.array([mfcc_mean[0],mfcc_mean[1], mfcc_mean[2],mfcc_mean[3],mfcc_mean[4],mfcc_mean[5],mfcc_mean[6],mfcc_mean[7],mfcc_mean[8],mfcc_mean[9],mfcc_mean[10],mfcc_mean[11],mfcc_mean[12],mfcc_mean[13],mfcc_mean[14],mfcc_mean[15],mfcc_mean[16],mfcc_mean[17],mfcc_mean[18],mfcc_mean[19],spectral_centroids, spectral_bandwidth,spectral_contrast, spectral_rolloff, meanfreq,\n", "                           maxfreq])\n", "    \n", "prediction=rfm.predict(input_features.reshape(1,-1))\n", "if prediction==1:\n", "    print(\"\ud1a4==\uc5ec\uc131\uc801\")\n", "    #\uc8fc\ud30c\uc218 \ub370\uc774\ud130\n", "    data = pd.read_csv('doremi_fre_girl.csv')\n", "\n", "    X = data.iloc[:, 0].values.reshape(42, 1)\n", "    y = data.iloc[:, 1]\n", "\n", "    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1)\n", "\n", "    dt = DecisionTreeClassifier(random_state=42)\n", "    dt.fit(X_train, y_train)\n", "\n", "    start = (0*sr)\n", "    end = (2*sr)\n", "    f0, voiced_flag, voiced_probs = librosa.pyin(y1[start:end], fmin=librosa.note_to_hz('C1'), fmax=librosa.note_to_hz('B4'))\n", "    valid_pitch = f0[~np.isnan(f0)]\n", "\n", "    pitch_mean = np.nanmean(valid_pitch)\n", "    pitch_mean_reshaped = pitch_mean.reshape(-1, 1)\n", "\n", "\n", "    predicted = dt.predict(pitch_mean_reshaped)  # \ubd84\ub958 \uacb0\uacfc \ucd9c\ub825\n", "    print(pitch_mean_reshaped,'-> \uc608\uc0c1 \ucd5c\uace0 \uc625\ud0c0\ube0c:', predicted)\n", "else:\n", "    print(\"\ud1a4==\ub0a8\uc131\uc801\")\n", "    #\uc8fc\ud30c\uc218 \ub370\uc774\ud130\n", "    data = pd.read_csv('doremi_fre_boy.csv')\n", "\n", "    X = data.iloc[:, 0].values.reshape(42, 1)\n", "    y = data.iloc[:, 1]\n", "\n", "    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1)\n", "\n", "    dt = DecisionTreeClassifier(random_state=42)\n", "    dt.fit(X_train, y_train)\n", "\n", "    start = (0*sr)\n", "    end = (2*sr)\n", "    f0, voiced_flag, voiced_probs = librosa.pyin(y1[start:end], fmin=librosa.note_to_hz('C1'), fmax=librosa.note_to_hz('B4'))\n", "    valid_pitch = f0[~np.isnan(f0)]\n", "\n", "    pitch_mean = np.nanmean(valid_pitch)\n", "    pitch_mean_reshaped = pitch_mean.reshape(-1, 1)\n", "\n", "    predicted = dt.predict(pitch_mean_reshaped)  # \ubd84\ub958 \uacb0\uacfc \ucd9c\ub825\n", "    print(pitch_mean_reshaped,'-> \uc608\uc0c1 \ucd5c\uace0 \uc625\ud0c0\ube0c:', predicted)\n", "    \n", "\n", "tone_result=prediction\n", "oc_result=pitch_mean_reshaped\n", "\n", "\n", "#---------------------------------------------------------------------------\n", "\n", "\n", "\n", "data = pd.read_csv(\"Song.csv\", encoding=\"euc-kr\")\n", "X = data.iloc[:, :-1]\n", "y = data.iloc[:, -1]\n", "\n", "X_train, y_train = X, y\n", "\n", "dt=DecisionTreeClassifier(max_leaf_nodes=4, random_state=55)\n", "dt_clt=dt.fit(X_train, y_train)\n", "\n", "mfcc = librosa.feature.mfcc(y=y1, sr=sr, n_mfcc=20)\n", "\n", "\n", "spectral_centroids = librosa.feature.spectral_centroid(y=y1, sr=sr)\n", "\n", "spectral_bandwidth = librosa.feature.spectral_bandwidth(y=y1, sr=sr)\n", "\n", "spectral_contrast = librosa.feature.spectral_contrast(y=y1, sr=sr)\n", "\n", "spectral_rolloff = librosa.feature.spectral_rolloff(y=y1, sr=sr)\n", "\n", "meanfreq = np.mean(spectral_centroids)\n", "\n", "maxfreq = np.max(spectral_centroids)\n", "\n", "\n", "mfcc_mean = np.mean(mfcc[:, 1:], axis=1).tolist()\n", "spectral_centroids = np.mean(spectral_centroids[spectral_centroids > 0])\n", "spectral_bandwidth = np.mean(spectral_bandwidth[spectral_bandwidth > 0])\n", "spectral_contrast = np.mean(spectral_contrast[spectral_contrast > 0], axis=0).tolist()\n", "spectral_rolloff = np.mean(spectral_rolloff[spectral_rolloff > 0])\n", "meanfreq = np.mean(meanfreq[meanfreq > 0])\n", "maxfreq = np.mean(maxfreq[maxfreq > 0])\n", "tone_results=prediction\n", "oc_results=oc_result\n", "\n", "\n", "\n", "input_features = np.array([mfcc_mean[0],mfcc_mean[1], mfcc_mean[2],mfcc_mean[3],mfcc_mean[4],mfcc_mean[5],mfcc_mean[6],mfcc_mean[7],mfcc_mean[8],mfcc_mean[9],mfcc_mean[10],mfcc_mean[11],mfcc_mean[12],mfcc_mean[13],mfcc_mean[14],mfcc_mean[15],mfcc_mean[16],mfcc_mean[17],mfcc_mean[18],mfcc_mean[19],spectral_centroids, spectral_bandwidth,spectral_contrast, spectral_rolloff, meanfreq,\n", "                           maxfreq,tone_results,oc_results,tone_results,oc_results,tone_results,oc_results,tone_results,oc_results,tone_results,oc_results,tone_results,oc_results,tone_results,oc_results,tone_results,oc_results,tone_results,oc_results,tone_results,oc_results,tone_results,oc_results,tone_results,oc_results,tone_results,oc_results])\n", "\n", "result1 = dt.predict(input_features.reshape(1, -1))\n", "print(f\"\uccab \ubc88\uc9f8 \ubd84\ub958 \uacb0\uacfc: [{result1}]\")\n", "\n", "X_updated = X[~y.isin(result1)]\n", "y_updated = y[~y.isin(result1)]\n", "\n", "dt_clt_updated = dt.fit(X_updated, y_updated)\n", "result2 = dt_clt_updated.predict(input_features.reshape(1, -1))\n", "print(f\"\ub450 \ubc88\uc9f8 \ubd84\ub958 \uacb0\uacfc: [{result2}]\")\n", "\n", "X_updated2=X_updated[~y.isin(result2)]\n", "y_updated2=y_updated[~y.isin(result2)]\n", "dt_clt_updated2 = dt.fit(X_updated2, y_updated2)\n", "result3=dt_clt_updated2.predict(input_features.reshape(1,-1))\n", "print(f\"\uc138 \ubc88\uc9f8 \ubd84\ub958 \uacb0\uacfc: [{result3}]\")"]}, {"cell_type": "code", "execution_count": null, "id": "194604ef", "metadata": {}, "outputs": [], "source": []}], "metadata": {"kernelspec": {"display_name": "Python 3 (ipykernel)", "language": "python", "name": "python3"}, "language_info": {"codemirror_mode": {"name": "ipython", "version": 3}, "file_extension": ".py", "mimetype": "text/x-python", "name": "python", "nbconvert_exporter": "python", "pygments_lexer": "ipython3", "version": "3.9.13"}}, "nbformat": 4, "nbformat_minor": 5}